name: Rcvo – Déploiement en toute sécurité (projet racine)

on:
  push:
    branches: [ main, principal ]
    paths:
      - "**/*.js"
      - "**/package.json"
      - ".github/workflows/deploy-full-safe.yml"
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  APP_NAME: rcvo-backend
  STAGING_ENV: Rcvo-Backend-staging
  PROD_ENV: Rcvo-Backend-prod
  BUCKET: rcvo-officiel
  HEALTH_PATH: /health
  SYNC_HEALTH: /health
  VERIFY_HEALTH: /health
  ALLOWED_ORIGIN: https://www.rcvo-crm-auto.com
  LABEL: build-${{ github.sha }}-${{ github.run_id }}-${{ github.run_attempt }}-${{ github.run_number }}

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node 22
        uses: actions/setup-node@v4
        with: { node-version: '22' }

      - name: Install deps
        run: npm ci || npm i

      - name: Pack (sans node_modules et .git)
        run: zip -r app.zip . -x "node_modules/*" ".git/*"

      - name: Auth AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Upload vers S3
        run: aws s3 cp app.zip "s3://${{ env.BUCKET }}/${{ env.APP_NAME }}/${{ env.LABEL }}.zip"

  deploy-staging:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Auth AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Attendre que STAGING soit prêt (pré-update)
        run: |
          for i in {1..120}; do
            OUT=$(aws elasticbeanstalk describe-environments --environment-names "${{ env.STAGING_ENV }}" \
              --query "Environments[0].[Status,Health,HealthStatus,AbortableOperationInProgress]" --output text)
            STATUS=$(echo "$OUT" | awk '{print $1}')
            HEALTH=$(echo "$OUT" | awk '{print $2}')
            HSTAT=$(echo "$OUT" | awk '{print $3}')
            ABRT=$(echo "$OUT" | awk '{print $4}')
            echo "Status=$STATUS Health=$HEALTH HealthStatus=$HSTAT Abortable=$ABRT"
            [ "$STATUS" = "Ready" ] && [ "$ABRT" = "false" ] && break
            sleep 15
          done

      - name: Créer version EB (idempotent)
        run: |
          aws elasticbeanstalk create-application-version \
            --application-name "${{ env.APP_NAME }}" \
            --version-label "${{ env.LABEL }}" \
            --source-bundle S3Bucket="${{ env.BUCKET }}",S3Key="${{ env.APP_NAME }}/${{ env.LABEL }}.zip" || true

      # ⬇️ Étape fusionnée : variables d'env + version + retries + attente fin d'update
      - name: Mettre à jour STAGING (vars + version, avec retry)
        run: |
          # 1) Re-check: attendre Ready sans opération en cours
          for i in {1..120}; do
            OUT=$(aws elasticbeanstalk describe-environments --environment-names "${{ env.STAGING_ENV }}" \
              --query "Environments[0].[Status,AbortableOperationInProgress]" --output text)
            STATUS=$(echo "$OUT" | awk '{print $1}')
            ABRT=$(echo "$OUT" | awk '{print $2}')
            echo "Pre-check -> Status=$STATUS Abortable=$ABRT"
            [ "$STATUS" = "Ready" ] && [ "$ABRT" = "false" ] && break
            sleep 10
          done

          # 2) Lancer update (vars + version) avec retries si refus "Doit être prêt"
          for i in {1..30}; do
            set +e
            aws elasticbeanstalk update-environment \
              --environment-name "${{ env.STAGING_ENV }}" \
              --version-label "${{ env.LABEL }}" \
              --option-settings \
                Namespace=aws:elasticbeanstalk:application:environment,OptionName=ALLOWED_ORIGIN,Value="${{ env.ALLOWED_ORIGIN }}" \
                Namespace=aws:elasticbeanstalk:application:environment,OptionName=JWT_SECRET,Value="${{ secrets.RCVO_JWT_SECRET }}" \
                Namespace=aws:elasticbeanstalk:application:environment,OptionName=ADMIN_EMAIL,Value="${{ secrets.RCVO_ADMIN_EMAIL }}" \
                Namespace=aws:elasticbeanstalk:application:environment,OptionName=ADMIN_PASSWORD,Value="${{ secrets.RCVO_ADMIN_PASSWORD }}"
            CODE=$?
            set -e
            if [ $CODE -eq 0 ]; then
              echo "Update lancé."
              break
            fi
            echo "Env non prêt, retry dans 10s… (tentative $i/30)"
            sleep 10
          done

          # 3) Attendre retour à Ready (fin d'update)
          for i in {1..120}; do
            OUT=$(aws elasticbeanstalk describe-environments --environment-names "${{ env.STAGING_ENV }}" \
              --query "Environments[0].[Status,Health,AbortableOperationInProgress]" --output text)
            STATUS=$(echo "$OUT" | awk '{print $1}')
            HEALTH=$(echo "$OUT" | awk '{print $2}')
            ABRT=$(echo "$OUT" | awk '{print $3}')
            echo "Post-check -> Status=$STATUS Health=$HEALTH Abortable=$ABRT"
            [ "$STATUS" = "Ready" ] && [ "$ABRT" = "false" ] && break
            sleep 15
          done

      - name: Attendre GREEN (STAGING)
        run: |
          for i in {1..80}; do
            H=$(aws elasticbeanstalk describe-environments --environment-names "${{ env.STAGING_ENV }}" --query "Environments[0].Health" --output text)
            S=$(aws elasticbeanstalk describe-environments --environment-names "${{ env.STAGING_ENV }}" --query "Environments[0].Status" --output text)
            echo "Health=$H Status=$S"
            [ "$H" = "Green" ] && [ "$S" = "Ready" ] && exit 0
            sleep 15
          done
          echo "STAGING pas Green/Ready à temps"; exit 1

      - name: Essais de fumée (STAGING)
        run: |
          URL="https://$(aws elasticbeanstalk describe-environments --environment-names "${{ env.STAGING_ENV }}" --query "Environments[0].CNAME" --output text)"
          for p in "${{ env.HEALTH_PATH }}" "${{ env.SYNC_HEALTH }}" "${{ env.VERIFY_HEALTH }}"; do
            ok=0
            for i in {1..15}; do
              code=$(curl -sk -o /dev/null -w "%{http_code}" "${URL}${p}")
              echo "${p} -> ${code}"
              [ "$code" = "200" ] && ok=1 && break
              sleep 3
            done
            [ $ok -eq 1 ] || { echo "Smoke failed on ${p}"; exit 1; }
          done

  promote-prod:
    runs-on: ubuntu-latest
    needs: deploy-staging
    steps:
      - name: Auth AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Mémoriser version actuelle PROD
        id: prev
        run: |
          PREV=$(aws elasticbeanstalk describe-environments --environment-names "${{ env.PROD_ENV }}" \
            --query "Environments[0].VersionLabel" --output text)
          echo "prev=${PREV}" >> $GITHUB_OUTPUT

      - name: Attendre que PROD soit prêt (pré-update)
        run: |
          for i in {1..120}; do
            OUT=$(aws elasticbeanstalk describe-environments --environment-names "${{ env.PROD_ENV }}" \
              --query "Environments[0].[Status,AbortableOperationInProgress]" --output text)
            STATUS=$(echo "$OUT" | awk '{print $1}')
            ABRT=$(echo "$OUT" | awk '{print $2}')
            echo "Status=$STATUS Abortable=$ABRT"
            [ "$STATUS" = "Ready" ] && [ "$ABRT" = "false" ] && break
            sleep 15
          done

      - name: Déployer en PROD
        run: aws elasticbeanstalk update-environment --environment-name "${{ env.PROD_ENV }}" --version-label "${{ env.LABEL }}"

      - name: Attendre GREEN (PROD)
        id: waitgreen
        continue-on-error: true
        run: |
          for i in {1..80}; do
            H=$(aws elasticbeanstalk describe-environments --environment-names "${{ env.PROD_ENV }}" --query "Environments[0].Health" --output text)
            S=$(aws elasticbeanstalk describe-environments --environment-names "${{ env.PROD_ENV }}" --query "Environments[0].Status" --output text)
            echo "Health=$H Status=$S"
            [ "$H" = "Green" ] && [ "$S" = "Ready" ] && exit 0
            sleep 15
          done
          exit 1

      - name: Post-checks (PROD)
        id: prodchecks
        continue-on-error: true
        run: |
          URL="https://$(aws elasticbeanstalk describe-environments --environment-names "${{ env.PROD_ENV }}" --query "Environments[0].CNAME" --output text)"
          for p in "${{ env.HEALTH_PATH }}" "${{ env.SYNC_HEALTH }}" "${{ env.VERIFY_HEALTH }}"; do
            ok=0
            for i in {1..15}; do
              code=$(curl -sk -o /dev/null -w "%{http_code}" "${URL}${p}")
              echo "${p} -> ${code}"
              [ "$code" = "200" ] && ok=1 && break
              sleep 3
            done
            [ $ok -eq 1 ] || { echo "PROD check failed on ${p}"; exit 1; }
          done

      - name: Auto-rollback si échec
        if: steps.waitgreen.outcome == 'failure' || steps.prodchecks.outcome == 'failure'
        run: |
          echo "Checks failed. Rolling back to ${{ steps.prev.outputs.prev }}"
          aws elasticbeanstalk update-environment --environment-name "${{ env.PROD_ENV }}" --version-label "${{ steps.prev.outputs.prev }}"
          exit 1
