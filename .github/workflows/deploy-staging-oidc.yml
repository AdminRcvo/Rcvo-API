name: D√©ploiement STAGING sur Elastic Beanstalk (OIDC)

on:
  push:
    branches: [ staging ]
  workflow_dispatch:
    inputs:
      env_name:
        description: "Nom de l'environnement EB"
        required: false
        default: "Rcvo-Backend-lb"

permissions:
  id-token: write
  contents: read

jobs:
  deployer:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: eu-west-3
      APP_NAME: Rcvo-backend
      ENV_NAME: ${{ github.event.inputs.env_name || 'Rcvo-Backend-lb' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Auth AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::409818814260:role/GithubOIDCRcvoDeploy
          aws-region: ${{ env.AWS_REGION }}

      - name: V√©rifier l‚Äôidentit√© AWS
        run: aws sts get-caller-identity

      - name: Installer Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Installer d√©pendances (lockfile si pr√©sent)
        shell: bash
        run: npm ci || npm install

      - name: Build (facultatif)
        run: npm run build --if-present

      - name: Cr√©er l‚Äôarchive √† d√©ployer
        run: zip -r app.zip . -x '.git/*' 'node_modules/*' 'app.zip'

      - name: D√©terminer le bucket EB (CreateStorageLocation idempotent)
        id: eb_bucket
        shell: bash
        run: |
          BUCKET=$(aws elasticbeanstalk create-storage-location --query S3Bucket --output text)
          echo "EB_BUCKET=$BUCKET" >> $GITHUB_ENV

      - name: Upload vers S3
        run: aws s3 cp app.zip "s3://${{ env.EB_BUCKET }}/app-${{ github.sha }}.zip"

      - name: Cr√©er / enregistrer la version d‚Äôappli
        run: |
          aws elasticbeanstalk create-application-version \
            --application-name "${APP_NAME}" \
            --version-label "${GITHUB_SHA}" \
            --source-bundle S3Bucket="${EB_BUCKET}",S3Key="app-${GITHUB_SHA}.zip" \
          || echo "Version d√©j√† existante"

      # ==== ATTENTE PRE-DEPLOIEMENT (fail-fast si env introuvable) ====
      - name: Attendre READY (pr√©-d√©ploiement)
        shell: bash
        run: |
          set -euo pipefail
          ENV="${ENV_NAME}"

          OUT="$(aws elasticbeanstalk describe-environments \
            --region "${AWS_REGION}" \
            --environment-names "$ENV" \
            --query 'Environments[0].[Status,Health]' --output text || true)"
          echo "Probe: $OUT"

          if [[ -z "$OUT" || "$OUT" == "None None" || "$OUT" == "None\tNone" ]]; then
            echo "‚ùå Environnement '${ENV}' introuvable dans ${AWS_REGION}."
            echo "üìã Environnements disponibles :"
            aws elasticbeanstalk describe-environments \
              --region "${AWS_REGION}" \
              --query 'Environments[].{Name:EnvironmentName,Status:Status,Health:Health}' \
              --output table || true
            exit 1
          fi

          MAX=60   # ~10 min
          for i in $(seq 1 $MAX); do
            OUT="$(aws elasticbeanstalk describe-environments \
              --region "${AWS_REGION}" \
              --environment-names "$ENV" \
              --query 'Environments[0].[Status,Health]' --output text || true)"
            STATUS="$(echo "$OUT" | awk '{print $1}')"
            HEALTH="$(echo "$OUT" | awk '{print $2}')"
            echo "STATUS=$STATUS  HEALTH=$HEALTH"
            if [[ "$STATUS" == "Ready" ]]; then
              echo "‚úÖ ${ENV} est READY (health=$HEALTH)."
              exit 0
            fi
            sleep 10
          done
          echo "‚ùå ${ENV} pas READY apr√®s ~10 min"; exit 1

      - name: D√©ployer sur l‚Äôenvironnement
        run: |
          aws elasticbeanstalk update-environment \
            --environment-name "${ENV_NAME}" \
            --version-label "${GITHUB_SHA}"

      # ==== ATTENTE POST-DEPLOIEMENT (pas de timeout-minutes GitHub !) ====
      - name: Attendre que l‚Äôenvironnement soit GREEN
        shell: bash
        run: |
          set -euo pipefail
          ENV="${ENV_NAME}"
          MAX=90  # ~30 min
          for i in $(seq 1 $MAX); do
            OUT="$(aws elasticbeanstalk describe-environments \
              --region "${AWS_REGION}" \
              --environment-names "$ENV" \
              --query 'Environments[0].[Health,Status]' --output text || true)"
            HEALTH="$(echo "$OUT" | awk '{print $1}')"
            STATUS="$(echo "$OUT" | awk '{print $2}')"
            echo "HEALTH=$HEALTH  STATUS=$STATUS"

            if [[ "$STATUS" == "Ready" && "$HEALTH" == "Green" ]]; then
              echo "‚úÖ ${ENV} est GREEN & READY."
              exit 0
            fi

            # Un mini-diagnostic toutes les ~2 minutes
            if (( i % 6 == 0 )); then
              echo "--- Derniers √©v√®nements EB (10 min) ---"
              aws elasticbeanstalk describe-events \
                --region "${AWS_REGION}" \
                --environment-name "$ENV" \
                --start-time "$(date -u -d '10 minutes ago' +%Y-%m-%dT%H:%M:%SZ)" \
                --max-records 50 \
                --query 'Events[].{At:EventDate,Sev:Severity,Msg:Message}' --output table || true
            fi
            sleep 20
          done
          echo "‚ùå Timeout attente GREEN (~30 min)"; exit 1

      - name: Test de fum√©e (/health)
        shell: bash
        run: |
          CNAME="$(aws elasticbeanstalk describe-environments \
            --region "${AWS_REGION}" \
            --environment-names "${ENV_NAME}" \
            --query 'Environments[0].CNAME' --output text)"
          URL="https://${CNAME}/health"
          echo "Test: $URL"
          for i in {1..15}; do
            code=$(curl -sk -o /dev/null -w "%{http_code}" "$URL" || true)
            echo "Tentative $i => HTTP $code"
            [[ "$code" == "200" ]] && { echo "‚úÖ Smoke OK"; exit 0; }
            sleep $((i*5))
          done
          echo "‚ùå Smoke KO"; exit 1
